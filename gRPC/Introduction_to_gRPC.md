
معرفی gRPC:

این مقاله شما را با gRPC و بافرهای پروتکل آشنا می کند. gRPC می تواند از بافرهای پروتکل هم به عنوان زبان تعریف رابط (IDL) و هم به عنوان قالب مبادله پیام زیربنایی خود استفاده کند.

بررسی اجمالی:

در gRPC، یک برنامه کلابنت می‌تواند مستقیماً یک متد را روی یک برنامه سرور در یک ماشین دیگر فراخوانی کند، همانند اینکه یک لوکال آبجکت است، و ایجاد برنامه‌ها و سرویس‌های توزیع‌شده را برای شما آسان‌تر می‌کند. مانند بسیاری از سیستم‌های  RPC، gRPC  مبتنی بر ایده تعریف یک سرویس است، روش‌هایی را که می‌توان از راه دور با پارامترها و انواع خروجی‌هایشان فراخوانی کرد، مشخص کرد. در سمت سرور، سرور این رابط را پیاده سازی می کند و یک سرور gRPC را برای رسیدگی به فراخوانی های کلاینت اجرا می کند. در سمت کلاینت، کلاینت یک stub دارد (که در برخی از زبان‌ها به آن کلاینت گفته می‌شود) که همان متدهای سرور را ارائه می‌دهد.

(عکس: <https://grpc.io/img/landing-2.svg>)

سرویس‌گیرندگان و سرورهای gRPC می‌توانند در محیط‌های مختلفی اجرا و با یکدیگر صحبت کنند - از سرورهای داخل Google گرفته تا دسک‌تاپ شما - و می‌توانند به هر یک از زبان‌های پشتیبانی‌شده gRPC نوشته شوند. بنابراین، به عنوان مثال، می توانید به راحتی یک سرور gRPC در جاوا با کلاینت هایی در  Go، Python  یا Ruby ایجاد کنید. علاوه بر این، آخرین  APIهای Google دارای نسخه‌های gRPC از رابط‌های خود هستند که به شما امکان می‌دهند به راحتی عملکرد Google را در برنامه‌های خود بسازید.



کار با بافرهای پروتکل

بهه‌طور پیش‌فرض، gRPC  از Protocol Buffers استفاده می‌کند، مکانیزم منبع باز بالغ Google  برای سریال‌سازی داده‌های ساخت‌یافته (اگرچه می‌توان از آن با سایر قالب‌های داده مانند JSON استفاده کرد).در اینجا یک مقدمه سریع برای نحوه عملکرد آن وجود دارد. 

اولین گام هنگام کار با بافرهای پروتکل، تعریف ساختار داده‌هایی است که می‌خواهید در یک فایل پروتو سریال‌سازی شوند: این یک فایل متنی معمولی با پسوند .proto است. داده‌های بافر پروتکل به صورت پیام‌هایی ساختار می‌شوند که در آن هر پیام یک رکورد منطقی کوچک از اطلاعات است که شامل یک سری جفت name-value به نام فیلد است. در اینجا یک مثال ساده است:

**message** **Person** {

`  `**string** name = 1;

`  `**int32** id = 2;

`  `**bool** has\_ponycopter = 3;

}

سپس، هنگامی که ساختار داده خود را مشخص کردید، از پروتکل کامپایلر بافر پروتکل برای تولید کلاس های دسترسی به داده در زبان(های) دلخواه خود از تعریف پروتو استفاده می کنید. اینها دسترسی‌های ساده‌ای را برای هر فیلد، مانند name() و set\_name()، و همچنین روش‌هایی برای سریال‌سازی/تجزیه کل ساختار به/از بایت‌های خام ارائه می‌کنند. بنابراین، برای مثال، اگر زبان انتخابی شما C++ باشد، اجرای کامپایلر در مثال بالا کلاسی به نام Person ایجاد می‌کند. سپس می توانید از این کلاس در برنامه خود برای پر کردن، سریال سازی و بازیابی پیام های بافر پروتکل Person استفاده کنید.

شما سرویس‌های gRPC را در فایل‌های پروتو معمولی تعریف می‌کنید، با پارامترهای متد RPC و انواع خروجی که به عنوان پیام‌های بافر پروتکل مشخص شده‌اند:

*// The greeter service definition.*

**service** Greeter {

`  `*// Sends a greeting*

`  `**rpc** SayHello (HelloRequest) **returns** (HelloReply) {}

}

*// The request message containing the user's name.*

**message** **HelloRequest** {

`  `**string** name = 1;

}

*// The response message containing the greetings*

**message** **HelloReply** {

`  `**string** **message** = 1;

}

از پروتک با یک پلاگین gRPC ویژه برای تولید کد از فایل پروتو استفاده می کند: شما کد سرویس گیرنده و سرور gRPC و همچنین کد بافر پروتکل معمولی را برای پر کردن، سریال سازی و بازیابی انواع پیام خود دریافت می کنید.

نسخه های بافر پروتکل

در حالی که بافرهای پروتکل برای مدتی در دسترس کاربران منبع باز بوده است، اکثر نمونه های این سایت از بافرهای پروتکل نسخه 3 (proto3) استفاده می کنند که دارای سینتکس کمی ساده شده، برخی ویژگی های مفید جدید و پشتیبانی از زبان های بیشتری است. Proto3 در حال حاضر در Java، C++، Dart، Python، Objective-C، C#، lite-runtime (Android Java)، Ruby و JavaScript از بافرهای پروتکل مخزن GitHub و همچنین یک جنریتور زبان Go از golang/ موجود است.
